[ktcclog]
# Log_level & logfile_level can be set to one of (0 = essential, 1 = info, 2 = debug, 3 = trace)
log_level: 3
logfile_level: 1

[toollock]
tool_lock_gcode:
tool_unlock_gcode:
init_printer_to_last_tool: False

[delayed_gcode check_active_tool_on_startup]
initial_duration: 1
gcode:
    DETECT_TOOL

[gcode_macro _TOOL_HOMING_OFFSET]
variable_homing_offset: 0.0
gcode:
  SET_GCODE_VARIABLE MACRO=_TOOL_HOMING_OFFSET VARIABLE=homing_offset VALUE={ params.Z }

[toolgroup 0]
dropoff_gcode:
  # Save GCode state
  SAVE_GCODE_STATE NAME=toolchange

  # Save Gcode XYZ, will need to restore it manually
  SAVE_CURRENT_POSITION RESTORE_POSITION_TYPE=2

  # Set XY offset to 0 so we park the tool right.
  SET_GCODE_OFFSET X=0 Y=0 Z={ printer["gcode_macro _TOOL_HOMING_OFFSET"].homing_offset }

  {% if printer.bed_mesh.profile_name %} 
    BED_MESH_PROFILE SAVE=toolchange  
    BED_MESH_CLEAR
  {% endif %}

  TAP_DROPOFF X={myself.park[0]} Y={myself.park[1]} Z={myself.park[2]} YS={myself.zone[1]}

pickup_gcode:
  # Put tool heater in Active mode
  M568 P{myself.name} A2

  TAP_PICKUP X={myself.park[0]} Y={myself.park[1]} Z={myself.park[2]} YS={myself.zone[1]}

  {% if 'toolchange' in printer.bed_mesh.profiles %}
    BED_MESH_PROFILE LOAD=toolchange
  {% endif %}

  # Restore GCODE state
  RESTORE_GCODE_STATE NAME=toolchange MOVE=0

  # Restore gcode state restores the old offset, so this comes after restore.
  SET_GCODE_OFFSET X={myself.offset[0]} Y={myself.offset[1]} Z={myself.offset[2]} MOVE=0

  # Move back to start position, with the correct gcode offsets applied
  RESTORE_POSITION

#[tools_calibrate]
#pin: ^!PF5
#travel_speed: 20
#spread: 7
#lower_z: 0.7
# The speed (in mm/sec) to move tools down onto the probe
#speed: 2
# The speed (in mm/sec) to retract between probes
#lift_speed: 4
#samples:3
#sample_retract_dist:2
#samples_tolerance:0.1
#samples_tolerance_retries:2
#samples_result:average
